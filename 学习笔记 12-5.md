# docker  
## what  
是一个开源的应用容器引擎，一个docker容器里面可以包含一套完整的软件运行环境。 

简单的理解，Docker类似于集装箱，各式各样的货物，经过集装箱的标准化进行托管，而集装箱和集装箱之间没有影响。也就是说，Docker平台就是一个软件集装箱化平台，这就意味着我们自己可以构建应用程序，将其依赖关系一起打包到一个容器中，然后这容器就很容易运送到其他的机器上进行运行，而且非常易于装载、复制、移除，非常适合软件弹性架构。  

因此，就像船只、火车或卡车运输集装箱而不论其内部的货物一样，软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。  

总而言之，Docker 是一个开放平台，使开发人员和管理员可以在称为容器的松散隔离的环境中构建镜像、交付和运行分布式应用程序。以便在开发、QA 和生产环境之间进行高效的应用程序生命周期管理。        
## when  
+ 节省项目环境部署时间  
1. 单项目打包  
每次部署项目到测试、生产等环境，都要部署一大堆依赖的软件、工具，而且部署期间出现问题几率很大，不经意就花费了很长时间。
Docker主要理念就是环境打包部署，可在任意Docker Engine运行。前期我们只需要将每个项目环境打包到镜像，push到镜像仓库，当有需要部署这个项目时，直接pull镜像启动容器，这个项目就可以访问了，一次构建多次部署，一劳永逸。
2. 整套项目打包  
公司有一项这样的业务：有一个产品可以整套部署到客户那里，以往都是派一名实施工程师到客户那部署。如果用了Docker，我们可以前期将这套项目封装打包起来，实现一键部署，就不需要再派人过去了。比如官方的Docker Compose编排工具。  
3. 新开源技术试用  
有时，想调研一些开源项目，可以直接从公共镜像仓库pull项目官方做好镜像启动容器即可。  
+ 环境一致性  
开发工程师在Windows系统上开发项目，测试、生产环境操作系统都是Linux系统，这就产生了环境不一致的情况：项目在开发电脑本地运行没问题，到了测试或生产环境就运行不起来，解决这问题最好方式就是这三处环境保持一致。  
Docker将项目环境打包成镜像，可以在任何Docker Engine上运用。  
+ 自动化测试和持续集成、发布  
+ 在服务型环境中部署和调整数据库或其他的后台应用  
+ 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境  
## why  
1. 快速，一致地交付应用程序  
Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。  
容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：  
- 开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。
- 他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。
- 当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。
- 测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。  
2. 响应式部署和扩展  
Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。  
Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。
3. 在同一硬件上运行更多工作负载  
Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。  
## 镜像（Image）：一个特殊的文件系统  
**只读**  
镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。  

镜像不包含任何动态数据，其内容在构建之后也不会被改变。  
镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。  

比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。  

在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。

因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。  

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。  
## 容器（Container）：镜像运行时的实体
**可写**  
镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。

容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。

按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。 

所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。

数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新 run，数据却不会丢失。  
**注意**：容器在整个应用程序生命周期工作流中提供以下优点：隔离性、可移植性、灵活性、可伸缩性和可控性。 最重要的优点是可在开发和运营之间提供隔离。  
## 仓库（Repository）：集中存放镜像文件的地方
镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。  

一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。  

所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。  

通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。  

可以通过<仓库名>:<标签>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。  

Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。  

除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。  
## docker常用命令及操作  
1. Docker安装、启动、停止  
yum install docker //安装docker  
systemctl start/stop Docker //启动/停止  
2. Docker中查找镜像（比如：mysql）  
docker search mysql //检索镜像  
3. 下载镜像  
docker pull mysql  
docker pull 镜像名:tag // tag标签是版本号，可选  
例如: docker pull mysql:5.5  
4. 查看所有本地镜像  
docker images  
Reporsitory | Tag | image_id | created  
5. 删除本地镜像  
docker rmi image-id  
## 容器操作  
Tomcat镜像安装程序 -- 运行镜像 -- 产生容器  
步骤：  
1. 查找镜像：docker search tomcat //查找tomcat镜像
2. 运行镜像：  
docker run --name container_name -d image_name  
// container_name：容器名  
// -d: 表示后台运行  
//image_name ：指定镜像模板 (通常情况是reposity:tag)  
例如：docker run --name mytomcat -d tomcat:latest  
3. 查看运行中的容器：docker ps
4. 查看所有的容器：docker ps -a
5. 停止/启动运行中的容器： docker stop/start 容器id/容器名
6. 删除容器：docker rm 容器id。 注意：删除前要先停止容器
7. 端口映射：  
-p 8080:8080  
//-p:表示将主机的端口映射到容器中的端口  
例如: docker run -d -p 8888:8080 tomcat //--name 可以省略
8. 查看容器的日志： docker logs 容器id/name  
## 数据持久化  
容器中的数据可以存储在容器层。但是将数据存放在容器层存在以下问题：  
- 数据不是持久化。意思是如果容器删除了，这些数据也就没了
- 主机上的其它进程不方便访问这些数据
- 对这些数据的I/O会经过存储驱动，然后到达主机，引入了一层间接层，因此性能会有所下降  
Docker 提供了3种持久化数据的方式：  
1. volumes：存于主机文件系统中的某个区域，由Docker管理（/var/lib/docker/volumes/ on linux）。非Docker进程不应该修改这些数据。卷是Docker中持久化数据的最好方式
2. bind mount：存于主机文件系统中的任意位置。非Docker进程可以修改这些数据
3. tmpfs mount（Linux中）：存于内存中（注意，并不是持久化到磁盘）。在容器的生命周期中，它能被容器用来存放非持久化的状态或敏感信息  
### volumes  
如果没有显式创建，一个卷会在最开始挂载时被创建。当容器停止时，卷仍然存在。多个容器可以通过read-write或read-only的方式使用同一个卷。

只有在显式删除时，卷才会被删除。**如果将一个空卷挂载到容器中一个存有文件或目录的目录中，这些文件或目录会被拷贝到空卷中；如果将一个非空卷挂载到容器中一个存有文件或目录的目录中，这些文件或目录会被隐藏**。  
- 创建：：docker volume create
- 删除某个卷：docker volume rm 卷名
- 删除所有未使用的卷：docker volume prune
- 列出所有卷：docker volume ls
- 查看某个卷的信息：docker volume inspect 卷名
- 挂载到容器：-v或--volume。如果是Docker17.06或更高：推荐使用--mount。（同 bind mount）
- 挂载类型：key为type，value为bind、volume或tmpfs
- 挂载源：key为source或src，对于命名卷，value为卷名，对于匿名卷，则忽略
- 容器中的挂载点：key为destination、dst或target，value为容器中的路径
- 读写类型：value为readonly，没有key
- volume-opt选项，可以出现多次。比如volume-driver=local,volume-opt=type=nfs,…
- 第一个域：对于命名卷，为卷名；匿名卷，则忽略，此时会创建匿名卷
- 第二个域：容器中的挂载点
- 第三个域：可选参数，由','隔开，如ro
- -v或—volume：由3个域组成，’:’分隔
- —mount：由多个','隔开的键值对 = 组成：  
当使用docker service create 启动Docker服务时，只支持--mount，不支持-v和--volume。并且每个服务容器使用它们各自的本地卷，因此如果使用本地(local)卷驱动，容器无法通过卷共享数据，但是一些卷驱动支持共享存储。Docker for AWS和Doocker for Azure都使用Cloundstor plugin支持持久存储。  
使用场景：  
+ 多个运行容器间共享数据
+ 当Docker主机不确保具有给定的目录或文件时。卷可以将容器运行时与Docker主机的配置解耦合
+ 备份、恢复、或将数据从一个Docker主机迁移到另一个Docker主机时  
### bind mount  
主机中的文件或目录通过全路径被引用。在使用绑定挂载时，这些目录或文件不一定要已经存在。

**如果使用这种方式将一个目录挂载到容器中一个存有文件或目录的目录中，这些文件或目录会被隐藏；如果主机中的文件或目录不存在，当使用--mount挂载时，Docker会报错，当使用-v或--volume时，会在主机上创建目录**。  
挂载到容器：-v或—volume。如果是Docker17.06或更高：推荐使用—mount。（同 volumes）  
- -v或--volume：由3个域组成，':'分隔
- 第一个域：对于命名卷，为卷名；匿名卷，则忽略，此时会创建匿名卷
- 第二个域：容器中的挂载点
- 第三个域：可选参数，由','隔开，如ro
--mount：由多个','隔开的键值对<key>=<value>组成：
- 挂载类型：key为type，value为bind、volume或tmpfs
- 挂载源：key为source或src，value为主机中文件或目录的路径
- 容器中的挂载点：key为destination、dst或target，value为容器中的路径
- 读写类型：value为readonly，没有key
- bind-propagation选项：key为bind-propagation，value为rprivate、private、rshared、shared、rslave或slave
- 一致性选项：value为consistent、delegated、cached。这个选项仅仅适用于Docker for Mac
- --mount不支持z和Z（这个不同于-v和—volume）  
使用场景  
大体上来说，只要可能，最好使用volumes

+ 主机与容器共享配置文件（Docker默认情况下通过这种方式为容器提供DNS解析，通过将/etc/resolv.conf挂载到容器中）
+ 共享源代码或build artifacts（比如将Maven的target/目录挂载到容器中，每次在Docker主机中build Maven工程时，容器能够访问到那些rebuilt artifacts）
+ 当 docker主机中的文件或目录结构和容器需要的一致时  
### bind propagation  
对于bind mount和volumes，默认都是rprivate。只有在使用bind mount时可配置，且必须在linux下。bind propagation是个超前主题，对于大多数用户来说，并不需要配置

对于一个挂载点/mnt，假设它同时也被挂载到/tmp。bind propagation控制 whether a mount on /tmp/a would also be available on /mnt/a




 




